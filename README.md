### **1.Go语言不支持重载**
- 主要原因是因为：多余的类型匹配会影响性能
### **2.defer是在最后执行**
- 但是它执行的值是在它的所放位置，在它后面改变的值不会起作用 
### **3.值传递、引用传递**
- 在Go语言中，值传递默认使用值的副本进行传递，也就是说改变了副本的值，不会影响原来的值，
- 如果想直接修改原来的传入原来的值的**内存地址即可，也就是&**
- 注意：几乎在任何情况下传递指针的消耗，都会比副本来得少,Go语言中默认使用值传递
- **&：表示获取指针**
- ***：将指针变为值**
- 像我们所熟悉的，**slice(切片)、map(字典)、interface(接口)、channel(通道)** 都是默认使用引用传递，虽然没有显示的指出指针
### **4.关于函数的方面的知识**
- 当给返回参命名且在函数体内进行赋值的时候，可以直接return   参考： mulitple_return.go
- 在定义函数中，**定义返回值尽量进行命名**，能够简单易懂，且好维护，保持好的编程习惯
- 空白符"_"
- 传递指针给函数不但可以节省内存,而且还赋予函数内改变传递指针的值,函数不需要再return 一个新的值出去 **mulitple_return.go  Multiply 函数**
- 如果要使用任意类型任意长度，可以使用...**interface{}**,一般这个搭配
- 匿名函数： 在我们不想给函数起名字的时候可以使用匿名函数, **function_literal.go**,在匿名函数花括号后面加上()即可 
- 将函数作为返回值，请看 **function_closure.go**
### **切片**

- 截取数组的一部分或者全部进行使用，切片的底层一定是一个数组作为支撑，在起始到结束，**结束那个下标是不会被包含的**
- 优点：切片是引用，不需要开辟新的内存空间，而且切片的使用更灵活。
- 切片的使用： var  slice=arr[:] 这样写就是包含了数组所有的数据,这里面的取值也是按照下标进行取值，且不包含结束下标的值
- 切片可当做数组使用  **cap 容量、len 长度**
- 数组和切片的区别：数组必须是固定长度，而切片可以不定义长度，且会根据数据的大小进行扩容
- 切片可以理解为为一个长度可变的数组
### **数组**

- Go的数组可以这样赋值   var arrayValue=[5]string{2:"你好",3:"Hello"}  **这样就是针对数组的下标赋值**
- var array=[...]string{"111","2222"}  这样的话相当于是切片
- 一般Go语言传递数组都会使用指针或者切片代替，因为直接传递数组会消耗大量的内存，数组越大，消耗越大。
- 数组了解一下就好，**在Go语言中通常使用切片**
    